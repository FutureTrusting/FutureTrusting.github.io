---
layout:     post
title:      JAVA内存
subtitle:   JAVA内存
date:       2020-04-03
author:     Square
header-img: img/wallhaven-zm3mxw.jpg
catalog: true
tags:
    - Interview
---

#### JAVA内存
##### 23、介绍下Java内存区域   
线程私有的:     
程序计数器: 程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；  
如果是在执行本地方法，则是未指定值（undefined）。  
Java虚拟机栈: 对应着一次次的Java方法调用。   
本地方法栈: 虚拟机对Native本地方法服务调用，也是每个线程都会创建一个。   
线程共享的:      
Java堆: 堆又分为新生代和老年代，是Java内存管理的核心区域，用来放置Java对象实例。   
方法区: 也称为永久代,用于存储元（Meta）数据，如类结构信息，运行时常量池、字段、方法代码等。   
JDK 8中将永久代移除，取而代之的是元数据区（Metaspace），元数据区使用的是直接内存  

运行时常量池: 方法区的一部分。Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用。  
JDK1.7之后JVM运行时常量池从方法区移除，在Java堆中开辟了一块区域存放运行时常量池  
只有程序计数器不会发生OOM，Java虚拟机栈，本地方法栈，Java堆，方法区，直接内存可能发生OOM  

-Xmx5G                      指定最大的堆大小  
-Xms2G                      指定初始堆大小  
-XX:NewSize=256m            指定新生代的最小256m的内存
-XX:MaxNewSize=1024m        指定新生代的最大1024m的内存
-XX:NewRatio=2                 
老年代与新生代(包括Eden和两个Survivor区)的大小比例。默认情况下，这个比例是2，也就是说老年代是新生代的2倍大。  
-XX:SurvivorRatio=value         
设置Eden与Survivor的大小比例，如果该值为8，代表一个Survivor是Eden的1/8，是整个新生代的1/10。 
-XX:PermSize=N              方法区 (永久代) 初始大小
-XX:MaxPermSize=N    
方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
-server -Xms512m -Xmx512m -Xss1024K     
Server模式启动  最小堆内存512m  最大512m  每个线程栈空间1m
XX:MaxTenuringThreshold=20XX:CMSInitiatingOccupancyFraction=80     
最大转为老年代检查次数20  Cms回收开启时机：内存占用80%      
XX:+UseCMSInitiatingOccupancyOnly       
命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期    

##### 1. 程序计数器为什么是私有的? 
序计数器用于记录当前线程执行的位置,如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址
##### 2. 虚拟机栈和本地方法栈为什么是私有的?
虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。
本地方法栈：本地方法栈则为虚拟机使用到的 Native 方法服务.
##### 3. 一句话简单了解堆和方法区
堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，
方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
##### 4. 对象的创建
类加载检查 -> 分配内存 -> 初始化零值 -> 设置对象头 -> 执行 init 方法
##### 5. Java堆
也被称作GC 堆,eden 区、s0("From") 区、s1("To") 区都属于新生代，tentired 区属于老年代   
Eden和Survivor默认比例为8:1   
对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1("To")，   
并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，  
当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中.   
大对象就是需要大量连续内存空间的对象（比如：字符串、数组）.   
##### 6. Minor GC 和 Full GC 有什么不同呢？
新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，回收速度比较快。   
老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。   
##### 6. 对象已经死亡？
引用计数法:    
给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用
可达性分析算法:   
当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。  
##### 7. 强引用、软引用、弱引用、幻象引用有什么区别？
强引用：常见的普通对象引用，只要强引用指向一个对象，垃圾收集器不会碰这种对象。    
软引用：只有当JVM认为内存不足时，才会去回收软引用指向的对象。     
弱引用：不能使对象豁免垃圾收集，当GC发现时会被回收。    
幻象引用：无法通过幻象引用获得对象。和没有任何引用一样，任何时候都会被垃圾回收。    
幻象引用仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。    
##### 8、Java常见的垃圾收集器有哪些，垃圾收集算法？  
Serial： 最早的单线程串行垃圾回收器    
ParNew： Serial收集器的多线程版本    
Parallel Scavenge： 使用复制算法的多线程收集器   
Parallel Scavenge: 类似ParNew收集器，更关注吞吐量（高效率的利用CPU）     
CMS： 一种以获得最短停顿时间为目标的收集器，注重用户体验,非常适用 B/S 系统     
G1： 一种兼顾吞吐量和停顿时间的 GC 实现, 是 JDK 9 以后的默认 GC 选项    
  
标记-清除算法: 标记无用对象，进行清除回收。 缺点： 效率不高， 无法清除垃圾碎片  
标记-整理算法: 标记无用对象，让所有存活的对象都向一端移动，然后清除掉端边界以外的内存  
复制算法： 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着对象复制到另一块上，   
然后再把已使用的内存空间一次清理掉。 缺点： 内存使用率不高， 只有原来的一半    
分代算法： 根据对象存活周期的不同将内存划分为几块，     
一般是新生代基本采用复制算法， 老年代采用标记整理算法  
##### 9. 请介绍类加载过程，什么是双亲委派模型？
类加载过程：加载、链接（验证->准备->解析）、初始化  
BootstrapClassLoader(启动类加载器）->  
ExtensionClassLoader(扩展类加载器）->  
AppClassLoader(应用程序类加载器）->  
自定义类加载器  

双亲委派模型介绍    
如果一个类加载器收到了类加载的请求， 它首先不会自己去加载这个类， 而是把这个请求委派给父类加载器去完成。    
所有的加载请求都会被传送到顶层的启动类加载器中， 只有当父加载无法完成加载请求时，子加载器才会尝试去加载类己来处理。  
当父类加载器为null时，会使用启动类加载器BootstrapC1assLoader作为父类加载器。  
双亲委派模型可以避免类的重复加载。  
如何打破双亲委派机制  
1、自己写一个类加载器 2、重写loadClass方法 3、重写findClass方法  
##### 10. 什么情况下会发生栈内存溢出。   
内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收，造成的内存溢出。      
如果出现这种现象可行代码排查：       
一）是否App中的类中和引用变量过多使用了Static修饰 如public static Student s;          
在类中的属性中使用 static修饰的最好只用基本类型或字符串。如public static int i = 0;    
二）是否App中使用了大量的递归或无限递归（递归中用到了大量的建新的对象）     
是否App中使用了大量循环或死循环（循环中用到了大量的新建的对象）   
##### 11. JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
为了提升GC效率，根据各个年代的特点使用垃圾收集算法
##### 12. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。
不可以，双亲委派模式会保证父类加载器先加载类，  
BootStrap（启动类）加载器加载jdk里面的java.lang.String类，     
自定义的java.lang.String类永远不会被加载到     

    
    
    
    
    
    
    
    
    
    
    